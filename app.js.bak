// Rust Loot Probabilities Viewer
(function(){
  const compareToggle = document.getElementById('compareToggle');
  
  const uploaderSingle = document.getElementById('uploaderSingle');
  const uploaderCompare = document.getElementById('uploaderCompare');
  const highlightWrap = document.getElementById('highlightWrap');
  const highlightDiffsToggle = document.getElementById('highlightDiffsToggle');
  const containerList = document.getElementById('containerList');
  const tablesWrapper = document.getElementById('tablesWrapper');
  const containerMeta = document.getElementById('containerMeta');
  const searchInput = document.getElementById('searchInput');
  

  const state = {
    sets: { A: createEmptySet(), B: createEmptySet() },
    activeSet: 'A',
    compare: false,
    highlightDiffs: true,
    activeContainer: null,
    names: { items: {}, containers: {} },
    unknown: { items: new Set(), containers: new Set() }
  };

  function createEmptySet(){
    return { containers: new Map(), containerOrder: [], files: [] };
  }

  fetch('assets/names.json')
    .then(r => r.ok ? r.json() : { items:{}, containers:{} })
    .catch(() => ({items:{}, containers:{}}))
    .then(n => { state.names = { items: n.items || {}, containers: n.containers || {} }; });

  for (const dz of document.querySelectorAll('.dropzone')){
    dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('drag'); });
    dz.addEventListener('dragleave', () => dz.classList.remove('drag'));
    dz.addEventListener('drop', e => { e.preventDefault(); dz.classList.remove('drag'); const target = dz.getAttribute('data-target'); handleFiles(e.dataTransfer.files, target); });
    dz.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') dz.querySelector('input[type=file]').click(); });
  }
  document.getElementById('fileInputA').addEventListener('change', e => handleFiles(e.target.files, 'A'));
  const fiA = document.getElementById('fileInputA_compare'); if (fiA) fiA.addEventListener('change', e => handleFiles(e.target.files, 'A'));
  const fiB = document.getElementById('fileInputB_compare'); if (fiB) fiB.addEventListener('change', e => handleFiles(e.target.files, 'B'));

  compareToggle.addEventListener('change', () => {
    state.compare = compareToggle.checked;
    uploaderSingle.hidden = state.compare;
    uploaderCompare.hidden = !state.compare;
    if (highlightWrap) highlightWrap.hidden = !state.compare;
    render();
  });

  if (highlightDiffsToggle){
    state.highlightDiffs = !!highlightDiffsToggle.checked;
    highlightDiffsToggle.addEventListener('change', () => { state.highlightDiffs = !!highlightDiffsToggle.checked; renderTables(); });
  }

  
  searchInput.addEventListener('input', () => renderTables());
  
  // initial UI state
  uploaderSingle.hidden = state.compare;
  uploaderCompare.hidden = !state.compare;
  if (highlightWrap) highlightWrap.hidden = !state.compare;

  function handleFiles(fileList, target){
    const files = Array.from(fileList || []);
    if (!files.length) return;
    Promise.all(files.map(readJsonFileSafe)).then(results => {
      for (const res of results){ if (!res) continue; addFileToSet(state.sets[target], res.name, res.data); }
      const set = state.sets[target];
      if (!state.activeContainer) state.activeContainer = set.containerOrder[0] || null;
      renderFileLists();
      render();
    });
  }

  async function readJsonFileSafe(file){
    try { const text = await file.text(); return { name: file.name, data: JSON.parse(text) }; } catch { return null; }
  }

  function addFileToSet(set, name, data){
    set.files.push({ name, data });
    mergeDataIntoSet(set, data);
  }

  function rebuildSet(set){
    const files = [...set.files];
    set.containers = new Map();
    set.containerOrder = [];
    for (const f of files){ mergeDataIntoSet(set, f.data); }
  }

  function removeFileFromSet(target, name){
    const set = state.sets[target];
    set.files = set.files.filter(f => f.name !== name);
    rebuildSet(set);
    if (!set.containerOrder.includes(state.activeContainer)){
      state.activeContainer = set.containerOrder[0] || null;
    }
    renderFileLists();
    render();
  }

  function renderFileLists(){
    const listA = document.getElementById('filesListA');
    const listA2 = document.getElementById('filesListA_compare');
    const listB2 = document.getElementById('filesListB_compare');
    if (listA){
      listA.innerHTML = '';
      state.sets.A.files.forEach(f => {
        const li = document.createElement('li');
        const span = document.createElement('span'); span.className = 'name'; span.textContent = f.name;
        const rm = document.createElement('span'); rm.className = 'remove'; rm.textContent = '×'; rm.title = 'Remove';
        rm.addEventListener('click', () => removeFileFromSet('A', f.name));
        li.appendChild(span); li.appendChild(rm); listA.appendChild(li);
      });
    }
    if (listA2){
      listA2.innerHTML = '';
      state.sets.A.files.forEach(f => {
        const li = document.createElement('li');
        const span = document.createElement('span'); span.className = 'name'; span.textContent = f.name;
        const rm = document.createElement('span'); rm.className = 'remove'; rm.textContent = '×'; rm.title = 'Remove';
        rm.addEventListener('click', () => removeFileFromSet('A', f.name));
        li.appendChild(span); li.appendChild(rm); listA2.appendChild(li);
      });
    }
    if (listB2){
      listB2.innerHTML = '';
      state.sets.B.files.forEach(f => {
        const li = document.createElement('li');
        const span = document.createElement('span'); span.className = 'name'; span.textContent = f.name;
        const rm = document.createElement('span'); rm.className = 'remove'; rm.textContent = '×'; rm.title = 'Remove';
        rm.addEventListener('click', () => removeFileFromSet('B', f.name));
        li.appendChild(span); li.appendChild(rm); listB2.appendChild(li);
      });
    }
  }

  function mergeDataIntoSet(set, json){
    for (const [container, body] of Object.entries(json || {})){
      if (!body || typeof body !== 'object') continue;
      const normContainer = normalizeContainer(container);
      if (!set.containers.has(normContainer)){
        set.containers.set(normContainer, { aggregated: [], combos: [], shortname: container, display: normContainer });
        set.containerOrder.push(normContainer);
      }
      const bucket = set.containers.get(normContainer);
      if (!bucket.shortname) bucket.shortname = container;
      bucket.display = normContainer;

      const probs = body.Probabilities || {};
      const amts = body.Amounts || {};
      for (const [key, chance] of Object.entries(probs)){
        const amounts = amts[key];
        if (!amounts) continue;
        const isCombo = key.includes(',');
        if (isCombo){
          const items = key.split(',').map(s => s.trim()).filter(Boolean);
          const combo = {
            key,
            items,
            chance: Number(chance),
            amounts: amounts.Min && amounts.Max ? { Min: amounts.Min, Max: amounts.Max } : null,
            conditions: amounts.Condition || null
          };
          bucket.combos.push(combo);
          items.forEach(short => ensureItemKnown(short));
        } else {
          const agg = {
            shortname: key,
            chance: Number(chance),
            amountMin: amounts.Min ?? null,
            amountMax: amounts.Max ?? null,
            minCondition: amounts.MinCondition ?? (amounts.Condition?.MinCondition ?? null),
            maxCondition: amounts.MaxCondition ?? (amounts.Condition?.MaxCondition ?? null)
          };
          bucket.aggregated.push(agg);
          ensureItemKnown(key);
        }
      }
    }
  }

  function normalizeItem(short){
    if (!short) return short;
    const name = state.names.items[short];
    if (!name) state.unknown.items.add(short);
    return name || short;
  }
  function normalizeContainer(short){
    if (!short) return short;
    const name = state.names.containers[short];
    if (!name) state.unknown.containers.add(short);
    return name || short;
  }
  function ensureItemKnown(short){
    if (!state.names.items[short]) state.unknown.items.add(short);
  }

  function render(){
    renderContainers();
    renderTables();
  }

  function renderContainers(){
    const targetSet = state.compare ? state.sets.A : state.sets[state.activeSet];
    const containers = new Set();
    if (state.compare){
      state.sets.A.containerOrder.forEach(c => containers.add(c));
      state.sets.B.containerOrder.forEach(c => containers.add(c));
    } else {
      targetSet.containerOrder.forEach(c => containers.add(c));
    }
    const list = Array.from(containers);
    if (list.length && !state.activeContainer) state.activeContainer = list[0];
    containerList.innerHTML = '';
    list.forEach(c => {
      const btn = document.createElement('button');
      btn.className = 'container-btn' + (c === state.activeContainer ? ' active' : '');
      const img = document.createElement('img'); img.alt = ''; img.src = `assets/containers/${c}.png`; img.onerror = () => { img.style.display = 'none'; };
      const labels = document.createElement('span'); labels.className = 'container-labels';
      const title = document.createElement('span'); title.textContent = c;
      const sub = document.createElement('span'); sub.className = 'sub';
      const bucket = (state.sets.A.containers.get(c) || state.sets.B.containers.get(c) || targetSet.containers.get(c));
      sub.textContent = bucket?.shortname || c;
      labels.appendChild(title); labels.appendChild(sub);
      btn.appendChild(img); btn.appendChild(labels);
      btn.addEventListener('click', () => { state.activeContainer = c; renderTables(); document.querySelectorAll('.container-btn').forEach(b => b.classList.toggle('active', b === btn)); });
      containerList.appendChild(btn);
    });
  }

  function createTable(headers){
    const table = document.createElement('table'); table.className = 'table';
    const thead = document.createElement('thead'); const trh = document.createElement('tr');
    headers.forEach(h => { const th = document.createElement('th'); th.textContent = h.label; th.dataset.key = h.key; th.addEventListener('click', () => {
      const current = th.classList.contains('th-sort-asc') ? 'asc' : th.classList.contains('th-sort-desc') ? 'desc' : null;
      trh.querySelectorAll('th').forEach(t => t.classList.remove('th-sort-asc','th-sort-desc'));
      const next = current === 'asc' ? 'desc' : 'asc'; th.classList.add(next === 'asc' ? 'th-sort-asc' : 'th-sort-desc');
      table.dispatchEvent(new CustomEvent('sort', { detail: { key: h.key, dir: next }}));
    }); trh.appendChild(th); }); thead.appendChild(trh);
    const tbody = document.createElement('tbody'); table.appendChild(thead); table.appendChild(tbody);
    return { table, tbody, headerRow: trh };
  }

  function renderTables(){
    tablesWrapper.innerHTML = '';
    containerMeta.innerHTML = '';
    const cName = state.activeContainer;
    if (!cName){ tablesWrapper.innerHTML = '<div class="small muted">Upload files to view tables.</div>'; return; }

    const img = document.createElement('img'); img.alt = ''; img.src = `assets/containers/${cName}.png`; img.onerror = () => { img.style.display = 'none'; };
    const labels = document.createElement('div'); labels.className = 'labels';
    const h = document.createElement('h3'); h.textContent = cName;
    const sub = document.createElement('div'); sub.className = 'sub';
    const bucketH = state.sets.A.containers.get(cName) || state.sets.B.containers.get(cName) || (state.sets[state.activeSet].containers.get(cName));
    sub.textContent = bucketH?.shortname || cName;
    labels.appendChild(h); labels.appendChild(sub); containerMeta.appendChild(img); containerMeta.appendChild(labels);

    const filterText = (searchInput.value || '').toLowerCase();
    

    if (!state.compare){
      const set = state.sets[state.activeSet];
      const bucket = set.containers.get(cName);
      if (!bucket){ tablesWrapper.textContent = 'No data for this container.'; return; }
      const { table } = buildTableForBucket(, (bucket.combos.length === 0), filterText);
      tablesWrapper.appendChild(table);
    } else {
      const left = state.sets.A.containers.get(cName) || { aggregated: [], combos: [] };
      const right = state.sets.B.containers.get(cName) || { aggregated: [], combos: [] };
      const useAggregated = (left.combos.length === 0 && right.combos.length === 0);

      const grid = document.createElement('div'); grid.style.display = 'grid'; grid.style.gridTemplateColumns = '1fr 1fr'; grid.style.gap = '12px';
      const aWrap = document.createElement('div'); const aTitle = document.createElement('div'); aTitle.className = 'small muted'; aTitle.textContent = 'Set A';
      const aTbl = buildTableForBucket(left, useAggregated, filterText).table; aWrap.appendChild(aTitle); aWrap.appendChild(aTbl);
      const bWrap = document.createElement('div'); const bTitle = document.createElement('div'); bTitle.className = 'small muted'; bTitle.textContent = 'Set B';
      const bTbl = buildTableForBucket(right, useAggregated, filterText).table; bWrap.appendChild(bTitle); bWrap.appendChild(bTbl);

      const aData = extractRowStats(left, useAggregated);
      const bData = extractRowStats(right, useAggregated);
      decorateDiffs(aTbl, aData, bData); decorateDiffs(bTbl, bData, aData);
      decoratePresence(aTbl, aData, bData); decoratePresence(bTbl, bData, aData);

      grid.appendChild(aWrap); grid.appendChild(bWrap); tablesWrapper.appendChild(grid);
    }
  }

  function extractRowStats(bucket, aggregated){
    const rows = new Map();
    if (aggregated){
      for (const it of bucket.aggregated){ const name = normalizeItem(it.shortname); rows.set(name, it.chance); }
    } else {
      for (const cb of bucket.combos){ const name = cb.items.map(normalizeItem).join(' + '); rows.set(name, cb.chance); }
    }
    return rows;
  }

  function decorateDiffs(table, selfMap, otherMap){
    const nameIdx = 0, chanceIdx = 2;
    for (const tr of table.querySelectorAll('tbody tr')){
      const name = tr.children[nameIdx]?.textContent?.trim();
      const chanceCell = tr.children[chanceIdx];
      if (!name || !chanceCell) continue;
      const a = selfMap.get(name); const b = otherMap.get(name);
      chanceCell.classList.remove('prob-up','prob-down'); const old = chanceCell.querySelector('.delta-chip'); if (old) old.remove();
      if (typeof a === 'number' && typeof b === 'number'){
        const diff = a - b;
        if (state.highlightDiffs){ if (diff > 0.0001) chanceCell.classList.add('prob-up'); else if (diff < -0.0001) chanceCell.classList.add('prob-down'); }
        const chip = document.createElement('span'); chip.className = 'delta-chip' + (diff > 0 ? ' up' : (diff < 0 ? ' down' : ''));
        chip.textContent = (diff === 0) ? '±0' : ((diff > 0 ? '+' : '') + fmtNum(diff)); chanceCell.appendChild(chip);
      }
    }
  }

  function decoratePresence(table, selfMap, otherMap){
    const nameIdx = 0;
    for (const tr of table.querySelectorAll('tbody tr')){
      tr.classList.remove('diff-only-a','diff-only-b');
      const name = tr.children[nameIdx]?.textContent?.trim(); if (!name) continue;
      const inSelf = selfMap.has(name); const inOther = otherMap.has(name);
      if (state.highlightDiffs){ if (inSelf && !inOther) tr.classList.add('diff-only-a'); if (!inSelf && inOther) tr.classList.add('diff-only-b'); }
    }
  }

  function buildTableForBucket(bucket, aggregated, filterText){
    const headers = [ { key: 'name', label: 'Item Name' }, { key: 'condition', label: 'Condition' }, { key: 'chance', label: 'Chance (%)' }, { key: 'amounts', label: 'Amounts' } ];
    const { table, tbody, headerRow } = createTable(headers);
    let rows = [];
    if (aggregated){
      const seen = new Set();
      rows = bucket.aggregated.filter(a => { if (seen.has(a.shortname)) return false; seen.add(a.shortname); return true; }).map(a => ({
        key: a.shortname,
        name: normalizeItem(a.shortname),
        icons: [a.shortname],
        short: a.shortname,
        condition: formatCond(a.minCondition, a.maxCondition),
        chance: a.chance,
        amounts: formatAmountRange(a.amountMin, a.amountMax)
      }));
    } else {
      const seen = new Set();
      rows = bucket.combos.filter(c => { if (seen.has(c.key)) return false; seen.add(c.key); return true; }).map(c => ({
        key: c.key,
        name: c.items.map(normalizeItem).join(' + '),
        icons: c.items.slice(),
        short: c.items.slice(),
        condition: formatComboCondition(c.conditions),
        chance: c.chance,
        amounts: formatComboAmounts(c.amounts)
      }));
    }

    if (filterText){ const ft = filterText.toLowerCase(); rows = rows.filter(r => r.name.toLowerCase().includes(ft)); }
    rows.sort((a,b)=> b.chance - a.chance);

    for (const r of rows){
      const tr = document.createElement('tr');
      const tdName = document.createElement('td');
      const nameCell = document.createElement('div'); nameCell.className = 'item-cell';
      const icons = document.createElement('div'); icons.className = 'item-icons';
      for (const short of r.icons){ const img = document.createElement('img'); img.alt = short; img.src = `assets/items/${short}.png`; img.onerror = () => { img.style.display = 'none'; }; icons.appendChild(img); }
      const labels = document.createElement('div'); labels.className = 'item-labels';
      const title = document.createElement('span'); title.textContent = r.name;
      const sub = document.createElement('span'); sub.className = 'sub'; sub.textContent = Array.isArray(r.short) ? r.short.join(' + ') : r.short;
      labels.appendChild(title); labels.appendChild(sub);
      nameCell.appendChild(icons); nameCell.appendChild(labels); tdName.appendChild(nameCell);

      const tdCond = document.createElement('td'); tdCond.innerHTML = r.condition || '<span class="muted">—</span>';
      const tdChance = document.createElement('td'); tdChance.textContent = fmtNum(r.chance);
      const tdAmt = document.createElement('td'); tdAmt.innerHTML = r.amounts || '<span class="muted">—</span>';
      tr.appendChild(tdName); tr.appendChild(tdCond); tr.appendChild(tdChance); tr.appendChild(tdAmt);
      tbody.appendChild(tr);
    }

    table.addEventListener('sort', ev => {
      const { key, dir } = ev.detail; const idx = headers.findIndex(h => h.key === key); const rowsArr = Array.from(tbody.querySelectorAll('tr'));
      rowsArr.sort((ra, rb) => { const a = ra.children[idx].textContent.trim(); const b = rb.children[idx].textContent.trim(); let cmp = 0; if (key === 'chance') cmp = (parseFloat(a)||0) - (parseFloat(b)||0); else cmp = a.localeCompare(b, undefined, { sensitivity:'base', numeric:true }); return dir === 'asc' ? cmp : -cmp; });
      tbody.innerHTML = ''; rowsArr.forEach(r => tbody.appendChild(r));
    });

    return { table, tbody };
  }

  function formatCond(min, max){
    const hasMin = min !== null && min !== undefined;
    const hasMax = max !== null && max !== undefined;
    if (!hasMin && !hasMax) return '';
    const m1 = hasMin ? fmtNum(min) : '—';
    const m2 = hasMax ? fmtNum(max) : '—';
    return `${m1} — ${m2}`;
  }

  function formatComboCondition(cond){
    if (!cond || typeof cond !== 'object') return '';
    const parts = [];
    for (const [short, v] of Object.entries(cond)){
      const m = formatCond(v?.MinCondition ?? null, v?.MaxCondition ?? null);
      if (m) parts.push(`${normalizeItem(short)}: ${m}`);
    }
    return parts.join('<br/>');
  }

  function formatComboAmounts(amts){
    if (!amts || typeof amts !== 'object') return '';
    const min = amts.Min || {}; const max = amts.Max || {};
    const items = new Set([...Object.keys(min), ...Object.keys(max)]);
    const parts = [];
    for (const s of items){
      const a = min[s], b = max[s]; if (a == null && b == null) continue;
      const m1 = a == null ? '—' : fmtNum(a); const m2 = b == null ? '—' : fmtNum(b);
      parts.push(`${normalizeItem(s)}: ${m1} — ${m2}`);
    }
    return parts.join('<br/>');
  }

  function formatAmountRange(min, max){
    if (min == null && max == null) return '';
    if (min == null) return `≤ ${fmtNum(max)}`;
    if (max == null) return `≥ ${fmtNum(min)}`;
    return `${fmtNum(min)} — ${fmtNum(max)}`;
  }

  function fmtNum(n){ return (typeof n === 'number' && !Number.isNaN(n)) ? (Math.round(n*1000)/1000).toString() : '0'; }

      render();
    }catch(err){ alert('Failed to load names.json: ' + err); }
    finally{ e.target.value = ''; }
  }
})();







